# Pyx Language Extension

**Pyx** は、Pythonのコーディング速度を上昇するために設計された、競技プログラミング特化型の強力なプリプロセッサ兼言語拡張です。

C++のテンプレートメタプログラミングのような柔軟性と、Pythonの書きやすさを融合。
マクロ展開、自動モジュラ演算、デバッグ機能、そして提出用コードの自動生成までをワンストップで提供します。

## ✨ 主な機能

- **強力なマクロシステム**: 関数型マクロ、メソッド型マクロ、定数置換。
- **静的条件分岐**: コンパイル時にコードを切り替える `!if`, `!elif`, `!else`。
- **自動モジュラ演算**: `$mod` 定義により `%+=` や `%+` などを自動展開。
- **デバッグ機能**: 実行時のみ有効になる `?` 行や `$debug` 定義。
- **スマート実行**: 実行エラーを元のソースコードの行番号で表示 (Source Map)。
- **自動処理**: 再帰の深さ制限自動解除、テストケースループ自動生成。

---

## 🚀 クイックスタート

1. `.pyx` ファイルを作成します（例: `main.pyx`）。
2. コードを書きます。
3. ショートカットキーで実行します。

| キー | 動作 |
| :--- | :--- |
| **`F5`** | **デバッグ実行** (コピーなし)。`?`行や `$debug`マクロが有効になります。 |
| **`Ctrl+Shift+B`** | **提出用ビルド＆実行**。正常終了後、**デバッグコードを除去した軽量コード**をクリップボードにコピーします。 |

---

## 📖 構文ガイド

### 1. マクロ定義 (`!macro`, `!define`)

```python
# 通常のマクロ
!macro pr(x): print(x)

# 可変長引数 (*args) と展開
!macro input_list(*a):
    a = list(map(int, input().split()))

# 定数定義
!define INF: 10**18

pr(INF)
input_list(L) # -> L = list(map(int, input().split()))
```

### 2. メソッド型マクロ (`!method`)
オブジェクト指向のように、変数やタプルに対してマクロを呼び出せます。

```python
# 変数に対して呼び出す (s がレシーバになる)
!method s.chmin(x):
    if s > x: s = x

dp[i].chmin(10) # -> if dp[i] > 10: dp[i] = 10

# タプルに対して呼び出す (u, v に分解)
!method (u,v).edge(w):
    G[u].append((v, w))
    G[v].append((u, w))

(1, 2).edge(100)
```

### 3. 静的条件分岐 (`!if`, `!elif`, `!else`)
コンパイル時に条件を評価し、必要なコードだけを残します。
マクロ引数の値や `!len` などの演算子を利用できます。

```python
!macro check(n):
    !if n == 1: print("One")    # 1行記法もOK
    !elif n == 2:
        print("Two")
    !else:
        print("Other")

check(1) # -> print("One")
```

### 4. マクロ演算子とスライス
マクロ引数に対して強力な操作が可能です。

- **`!len(a)`**: 引数 `a`（リスト）の長さを取得。
- **`a![i]`**: 引数 `a` の `i` 番目の要素を取得。
- **`a![start:end]`**: 引数をスライスしてカンマ区切りで展開。
- **`a` (そのまま)**: 可変長引数の場合、自動的に `a![:]` (全展開) として扱われます。

```python
!macro rotate(*a):
    print(a![1:], a![0]) # 2番目以降, 1番目

rotate(1, 2, 3) # -> print(2, 3, 1)
```

---

## ⚡ 競技プログラミング特化機能

### 1. 自動モジュラ演算 (`$mod`)
`$mod` を定義すると、専用の演算子が使えるようになります。
代入演算子に加え、二項演算子もサポートしています。

```python
$mod 998244353

# 代入演算子
a %+= b  # -> a = (a + (b)) % 998244353
a %*= b  # -> a = (a * (b)) % 998244353
a %-= b  # -> a = (a - (b)) % 998244353
a %/= b  # -> a = (a * pow(b, 998244353-2, 998244353)) % 998244353 (逆元)

# 二項演算子 (式の中で利用可能)
x = a %+ b  # -> x = ((a) + (b)) % 998244353
x = a %- b  # -> x = ((a) - (b)) % 998244353
x = a %* b  # -> x = ((a) * (b)) % 998244353
x = a %/ b  # -> x = ((a) * pow(b, 998244353-2, 998244353)) % 998244353
```

### 2. デバッグ行 (`?`) とデバッグ定義 (`$debug`)
これらは **`F5` (実行)** の時のみ有効になり、**`Ctrl+Shift+B` (提出)** の時はコードから**完全に削除**されます。

```python
# デバッグ実行時のみ print される
?print("Debug info:", dp)

# デバッグ実行時のみ有効なマクロ (同名のマクロを上書き可能)
$debug !macro debug(x): print(x)
!macro debug(x): pass

debug("Hello")
```

### 3. テストケースループ (`$cases`)
指定された回数分ループするコードを自動生成します。引数が `1` の場合はループしません。

```python
!define _T: int(input())
$cases _T
    solve()
```

### 4. 名前空間とテンプレート機能
ライブラリ管理に最適です。引数を受け取ることで、C++のテンプレートのように汎用的なコードを記述できます。

```python
# 引数付き名前空間の定義
$namespace SegmentTree(op, e)
    !macro build():
        # op や e を使ったコード
        data = [e] * N
$

# デフォルト引数付きの1行定義
$name Graph(N=200000) G = [[] for _ in range(N)]

# 外部ファイルの読み込み (再帰的に展開されます)
$expand ./library/graph.pyx

# 名前空間の使用 (引数を指定して展開)
$using SegmentTree(max, -1)
$using Graph(10)
```

### 5. 自動再帰リミット解除
コード内に再帰関数（自分自身を呼び出す関数）を検知すると、自動的に冒頭へ以下を追加します。
```python
import sys
sys.setrecursionlimit(10 ** 6)
```

---

## ⚙️ 設定 (VS Code Settings)

| 設定項目 | 説明 | デフォルト |
| :--- | :--- | :--- |
| `pyx.showDisclaimer` | 生成コード先頭の免責事項を表示 | `true` |
| `pyx.showOriginalCode` | 元のPyxコードをコメントとして残す | `true` |
| `pyx.disclaimerText` | 免責事項の文章 | (デフォルト文) |
| `pyx.commentStyle` | コメント記号 | `'''` |

---

## 📝 記述例

```python
$mod 10**9+7
!macro chmax(a, b):
    if a < b: a = b

N = int(input())
dp = [0] * (N + 1)

?print("Start DP") # 提出時には消える

for i in range(N):
    # 自動mod演算 (二項演算子と代入演算子)
    dp[i+1] %+= dp[i] %* 2
    
print(dp[N])
```

---

**Happy Coding with Pyx!**
